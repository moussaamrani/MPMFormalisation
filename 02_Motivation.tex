\section{Motivation}
\label{sec:Motivation}

\moussa{This is a copy/paste of Hans' email for now, and need to be rewritten 
appropriately. It should at least:
\begin{itemize}
   \item Introduce the MPM motto (``model everything explicitly, with the most 
appropriate formalisms, etc.'');
   \item Introduce what would be the essence and role of the Modelverse (and 
cite Yentl's Ph.D???);
   \item Explain why a first step (namely, ``mono-paradigm'') is essential to 
capture the essence of what a paradigm is, through our paradigmatic structure / 
props, and therefore introduce Table \ref{ParadigmProperties}\end{itemize}}

- being able to give a "label/name" to a paradigm, i.e., a collection of 
formalisms/abstractions/processes
  satisfying certain properties makes it possible to reason about the 
"appropriateness" of
  that paradigm for a particular task.
  If, for example, we wish to describe the behaviour of a system where 
operations on data are
  trigerred by the availability of data, then "data flow" seems most 
appropriate.
  Note that the "data flow" properties pertain to the formalism part of the 
paradigm properties.
  If, as another example, we know that at the start of a project, requirements 
are certain and
  that during the course of the project, requirements are likely to change 
frequently,
  then "agile" seems most appropriate.
  Note that the "agile" properties pertain to the process/workflow part of the 
paradigm properties.
- based on a precise definition of a paradigm, one can design (software) 
architectures
  to support modelling in that paradigm. Given the common structure 
formalisms/abstractions/processes
  of a paradimg, such a (tool) architecture will have to support 
formalisms/abstractions/processes.
  The first (formalisms) means that the explicit modelling of concrete and 
abstract syntax as
  well as semantics is necessary (with subsequent synthesis of a 
modelling/analysis/simulation/execution/debugging/...  (tool) environment).
  This is also known as Modelling Language Engineering (though we would call it 
Modelling Formalism Engineering).
  The second (abstractions) means that some infrastructure must be provided for 
relating models at different
  levels of abstraction (with respect to the satisfaction of given set of 
properties -- note that these properties
  are model properties, not formalism/abstraction/process properties). At an 
operational level, this
  implies that model transformations will have to be supported. Such 
transformations may be uni-directional or
  more generally may rather be formalisations of the relationships that must 
hold between the models.
  The third (processes) means that explicit modelling of workflow, with 
subsequent enactment, must be supported.
  Here again, the need for explicit modelling of model transformations arises.
- The FTG+PM, an artefact useful in the explicit modelling of 
formalisms/abstractions/processes can be used in many ways:
  (1) The FTG is obtained by querying the repository of all modelling artefacts 
(system models, transformation models,
      formalism models, workflow models, ...), aka the "Modelverse", for those 
artefacts that are formalism specifications.
      Note that it is thus (a) a projection of the full "Modelverse" and (b) a 
snapshot, as the "Modelverse" will evolve over time.
      Additional properties may be used in the query, asking for example only 
for discrete-time formalisms.
      The FTG can then be used to "chart" formalisms used as well as their 
relationships (and which model properties
      these relationships preserve). To give meaning to coupled models in which 
the component models are described in
      different formalisms, that chart can subsequently be used to find the most 
appropriate ("highest") common formalism onto which
      the models in diverse formalisms can be mapped. The assumption is that the 
semantics of a coupled model with
      all component models in the same formalism is known, or easier to specify.
      Once the required mappings/transformations are obtained, the necessary 
formalism transformation steps can be
      included in an appropriate order, in the process model (PM).
  (2) One may observe an existing workflow and supporting formalisms/tooling and 
chart it in an FTG+PM.
      This may require adding new formalisms in the "Modelverse".
  (3) A PM may be used to (a) check conformance of engineers' activities with 
it, (b) as a set of constraints
      over engineers' activities, or (c) as a basis for "enactment".
      Traditionally, these are called "descriptive", "proscriptive" and 
"prescriptive" process models.
      (c) is the basis for "toolchains" whereby existing 
modelling/analysis/simulation tools are orchestrated
      based on the PM using enablers such as OSLC.
  (4) Possibly based on existing workflows, one may start with a PM and type it 
appropriately with formalisms (for the
      artefacts) and relations (for the activities) from the FTG.
- it sets the stage for a formalization of the notion of multi-paradigm. 



\begin{table}[t]
  \caption{Properties of two paradigms: Object Orientation ($\mathsf{OO} 
  \cite{Wegner:1987}$) and Computer-Aided Design ($\mathsf{CAD} 
  \cite{B:Groover-Zimmers:2008}$)}
   \begin{center}
      \begin{tabular}[t]{c l}
         \hline
         \multicolumn{2}{l}{$\iota_1$: Object Orientation ($\mathsf{OO}$)}\\
         \hline
         $\mbox{OO}_1$ & Possess the concepts of Object and Class\\
         $\mbox{OO}_2$ & Objects possess a state and a set of capabilities / 
operations \\
         $\mbox{OO}_3$ & Possess an inheritance mechanism\\
         $\mbox{OO}_4$ & Inheritance allows to reuse operations\\
         \hline\hline
         \multicolumn{2}{l}{$\iota_2$: Computer-Aided Design ($\mathsf{CAD}$)}\\
         \hline
         $\mbox{CAD}_1$ & Comprises concepts of (2D/3D) points and lines\\
         $\mbox{CAD}_2$ & Shapes are defined by lines\\
         $\mbox{CAD}_3$ & Supports transformation of shapes into (2D/3D) 
products\\
         \hline
      \end{tabular}
   \end{center}
   \label{ParadigmProperties}
   
\end{table}
