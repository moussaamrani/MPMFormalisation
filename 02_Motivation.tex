\section{Motivation}
\label{sec:Motivation}

For developing a \textsc{Cps}, project managers and engineers need to figure 
out what core properties the future system has, and select the most 
appropriate development languages, software lifecycles and ``interfaces'' to 
make the different views and components of their system communicate 
appropriately. For example, when a manager knows that system/software 
requirements are likely to change frequently during the project's course, 
selecting an Agile development process may likely help handle evolution and 
change. If the system's behaviour requires that operations are triggered when 
data become available, similar to reactive systems, relying on Data Flow 
languages may help handle the most critical part of the software behaviour. 

\textsc{Mpm} requires to \emph{model everything explicitly}, with \emph{the 
most appropriate formalisms}, \emph{at the most appropriate abstraction level} 
\cite{PhD:VanTandeloo:2017}. This suggest that a \emph{paradigm} is a 
placeholder for describing the properties of each of the dimensions described 
above: the \emph{formalisms}, the \emph{abstraction levels}, and the 
\emph{processes} that enable interactions between all the basic modelling 
activities. Ultimately, \textsc{Mpm} aims at providing the tool machinery and 
support for helping managers and engineers select, organise and manage the 
three dimensions above. We aim at clarifying the formal foundations of 
\textsc{Mpm} to help design these tools. This paper represents a first step 
where we ignore the abstraction dimension for now and focus on the others, but 
we motivate here why those dimensions are necessary and how they integrate 
together.

\noindent
\textbf{Formalisms/Languages.} The first dimension relate to what is otherwise 
known as \emph{Modellng Languages Engineering}, i.e. the explicit modelling of 
the key components of (modelling) languages: concrete and abstract (i.e. 
metamodels) syntaxes, as well as semantics, together with the usual activities 
around: analysis, simulation, execution, debugging, etc. that should be 
supported by tools that may be largely synthesized from high-level 
specifications of these languages and their usage. These multiple languages are 
organised in a repository that we call the \emph{Modelverse} intended to be 
dynamically evolving over time.

\noindent
\textbf{Abstraction / Viewpoints.} Since \textsc{Mpm} integrate multiple users 
all with different concerns, an infrastructure should be provided for relating 
models at different abstraction levels, while ensuring that certain 
language-related properties still hold to ensure a consistent manipulation. 

\noindent
\textbf{Processes.} Many workflows govern the various \textsc{Mpm} activities 
for engineering languages in a concern-consistent way, but also to support 
lifecycles and development processes by connecting models in tool chains to 
achieve larger workflows. To capture this dimension, we rely on a structure 
called \textsc{Ftg+Pm} \cite{Mustafiz-etAl:2012} tightly connected to the 
Modelverse: the Modelverse may be queried to obtain any modelling artefact 
(related to languages of course, but also the processes themselves), providing 
a snapshot at the current time of the relevant artefacts that may be helpful 
(e.g. for the general tasks described above), or providing a partial projection 
of the full Modelverse to be reasoned over. Processes play their full role: 
they may be \emph{descriptive}, allowing to check that engineers follow the 
appropriate activities towards project completion; \emph{proscriptive} by 
putting limits and constraints on what engineers may consider as valid 
activities; and \emph{prescriptive} by enacting the specific tasks to follow. 
This \textsc{Ftg+Pm} also enables reasoning over shared parts of, and 
relationships between languages to give meaning to various models aimed at 
being used together: for example, finding the highest language (in terms of a 
mathematical order over the formalisms supported by these languages) to which 
all relevant models may be mapped, enabling easier reasoning, analysis or 
(co-)execution.

All three dimensions have at their core the use of \emph{model transformation}: 
for achieving the various activities for engineering languages (cf. 
\cite{J:Lucio-Amrani-etAl:2014}), for specifying the multiview relationships 
between models, or for performing the various activities in their defining 
processes. Furthermore, they may also provide the basic manipulations necessary 
for querying, extracting and projecting the Modelverse.

\begin{table}[t]
  \caption{Properties of two paradigms: Object Orientation ($\mathsf{OO} 
  \cite{Wegner:1987}$) and Computer-Aided Design ($\mathsf{CAD} 
  \cite{B:Groover-Zimmers:2008}$)}
   \begin{center}
      \begin{tabular}[t]{c l}
         \hline
         \multicolumn{2}{l}{$\iota_1$: Object Orientation ($\mathsf{OO}$)}\\
         \hline
         $\mbox{OO}_1$ & Possess the concepts of Object and Class\\
         $\mbox{OO}_2$ & Objects possess a state and a set of capabilities / 
operations \\
         $\mbox{OO}_3$ & Possess an inheritance mechanism\\
         $\mbox{OO}_4$ & Inheritance allows to reuse operations\\
         \hline\hline
         \multicolumn{2}{l}{$\iota_2$: Computer-Aided Design ($\mathsf{CAD}$)}\\
         \hline
         $\mbox{CAD}_1$ & Comprises concepts of (2D/3D) points and lines\\
         $\mbox{CAD}_2$ & Shapes are defined by lines\\
         $\mbox{CAD}_3$ & Supports transformation of shapes into (2D/3D) 
products\\
         \hline
      \end{tabular}
   \end{center}
   \label{tab:Properties}
\end{table}
