\section{Formalisation}
\label{sec:Formalisation}

Our formalisation defines a \emph{paradigm} as a set of 
\emph{characterising properties} $\mathsf{\Pi}$ that holds over a mathematical 
construction called a \emph{paradigmatic structure} $\mathsf{PS}\in \PS$. 
This structure describes a specific \emph{workflow} (or \emph{process}) that 
captures how specific \emph{languages instances} are combined together, 
through transformations, towards achieving a specific intent $\iota$ that is 
adequately characterised by the properties. When $\iota$ has a commonly agreed 
name (in a given context, or for a specific community), and $\mathsf{\Pi}$ holds 
on a specific $\mathsf{PS}$, then $\mathsf{PS}$ is said to \emph{qualify} as 
the paradigm $\iota$. The properties constituting $\mathsf{\Pi}$ may 
characterise the formalisms and/or the workflow defining a paradigmatic 
structure. 

\subsection{Preliminaries}
\label{sec:Formalisation-Preliminaries}

We assume in this paper that ``\emph{everything is modelled explicitly}`` by 
using \emph{models} conformant to \emph{metamodels}, themselves explicitly 
modelled (using a \emph{meta-metamodel}). The following definition introduces 
precise notations for these notions.

\begin{Definition}[(Meta-)Models \& Conformance]
   Let $\mathbb{M}$ and $\mathcal{M}$ be the sets of all models and metamodels 
respectively, as defined by meta-metamodels. For a model $\mathsf{M} \in 
\mathbb{M}$ and a metamodel $\mathsf{MM} \in \mathcal{M}$, we write $\mathsf{M} 
\rhd \mathsf{MM}$ if $\mathsf{M}$ \emph{conforms to} $\mathsf{MM}$.
\end{Definition}
This definition explicitly distinguishes between two meanings for what is 
called an \emph{instance}, namely the difference between \emph{linguistic} and 
\emph{ontological} instantiation \cite{J:Kuhne:2006}. \textsf{M} and \textsf{MM} 
are \emph{valid} (linguistic) instances of their respective meta-metamodels in 
the sense that they belong to the valid ''\emph{phrases}'' that the 
meta-metamodel defines; whereas the fact that \textsf{M} is an 
\emph{ontological} instance of \textsf{MM} needs to be checked, making 
\textsf{M} conform to \emph{MM}. This checking procedure has been extensively 
described by many previous contributions (see e.g. \cite{PhD:Amrani:2013}).

The choice of a specific meta-metamodel determines the thechnological space 
chosen for metamodelling \cite{Wimmer-Kramler:2005}: \emph{grammarware} have a 
tree-based structure and are fully textual; whereas \emph{modelsware} are either 
visual or textual (or both), and rely either on \textsc{Mof}-like tree-based 
(meta-)metamodels, or Graph Theory. 


% Take as a simple example \emph{object orientation} as a fairly recognised 
% intent, which may translate into the following list of properties: the 
% existence of objects possessing an identity; a notion of class that types 
% objects, and that defines data and functions of these objects; a relation on 
% classes called inheritence that allows objects of one class to acquire 
% properties of objects of another class; and the existence of a message passing 
% mechanism between objects. 
% \moussa{Maybe factor out this description in a previous section dedicated to 
% provide the intuition about paradigms?}. 

% \begin{Definition}[Transformation]
%    A \emph{transformation specification} $\mathsf{T}\in\mathbb{T}$ is a triple 
% $\mathsf{T} = ()$
% \end{Definition}

In order to designate specific items of our formalisation explicitly by their 
name, we define distinct namespaces as sorted sets. Properly resolving 
namespaces is out of scope, as it relies on specific tooling 
capabilities and implementation choices.

\begin{Definition}[Names]
   The sorted set $\mathsf{Name}$ of \emph{names} defines namespaces over 
\emph{items}.
   \begin{displaymath}
   \begin{small}
     \begin{array}{rcl}
		\mathsf{Item} & \eqdef & \{\mathsf{Language}, \mathsf{Transformation}, \\
                    &        & \mathsf{LangInstance}, \mathsf{TransInstance}\}\\
		\mathsf{Name}    & \eqdef & (\mathsf{Name}_{_{\mathsf{e}}})_{_{\mathsf{e} 
\in \mathsf{Item}}}
      \end{array}
   \end{small}
\end{displaymath}
\end{Definition}
To avoid the subscripted notation, we introduce a more compact notation for 
referring to names: for example, the set of class names 
$\mathsf{Name_{_{Language}}}$ will be noted $\mathsf{LanguageN}$.  

\subsection{Formalism \& Language}
\label{sec:Formalism-Language}

We first introduce a distinction between \emph{formalisms} and \emph{languages}: 
a \emph{formalism} is a mathematical construction built for capturing the 
\emph{essence} and the \emph{core concepts} of a software \emph{language}. 

\begin{Definition}[Formalism]
   A \emph{formalism} $F\in\mathbb{F}$ is a triple $F = (\mathsf{AS}, 
\SMapping, \mathsf{SD})$, where $\mathsf{AS}\in\mathcal{M}$ is a metamodel 
defining an \emph{abstract syntax}; $\mathsf{SD}\in\mathbb{D}$ is a 
\emph{semantic domain}; and $\SMapping 
\colon \mathsf{AS} \to \mathsf{SD}$ is a \emph{semantic mapping} that uniquely 
associates to each valid abstract syntax instance a meaning (or interpretation) 
in terms of the semantic domain.
\end{Definition}

Translating the core concepts captured by a formalism into a usable software 
language requires the definition of a \emph{concrete semantics} for 
users/modellers to manipulate language instances.

% For example, Finite State 
% Automata (\textsc{Fsa}), as originally defined by Moore \cite{J:Moore:1956}, 
% define the 
% state-transition computations. However, to be useful in practice, a 
% \emph{concrete syntax} is needed in order to manipulate concrete instances, 
% allowing the definition of languages.

 \begin{Definition}[Language]
   A \emph{language specification} (or \emph{language} 
for short) $\mathsf{L}\in\mathbb{L}$ is a tuple $\mathsf{L} = (\mathsf{CS}, 
\mathsf{AS}, \SMapping, \mathsf{SD})$ where $\mathsf{CS}\in\mathcal{M}$ is a 
\emph{concrete syntax} for representing elements of the language;  
$\mathsf{AS}\in\mathcal{M}$ is an \emph{abstract syntax}; 
$\mathsf{SD}\in\mathbb{D}$ is 
a \emph{semantic domain}; and $\SMapping \colon \mathsf{AS} \to \mathsf{SD}$ is 
a \emph{semantic mapping}. 

   A \emph{language instance} $\mathsf{LI}\in\mathbb{M}$ of a language 
$\mathsf{L}\in\mathbb{L}$ is a model conform to $\mathsf{AS}$ (i.e. 
$\mathsf{LI} \rhd \mathsf{AS}$) and defined using \textsf{CS}.
\end{Definition}

\smallskip\noindent
Our definition for languages is \emph{extentional}: it only specifies the sets 
involved in the structure of a language (as advocated e.g. by Harel \& Rumpe 
\cite{J:Harel-Rumpe:2004}), without providing a constructing approach to 
manipulate them. However, effectively checking that a language instance 
conforms to its specification requires an \emph{intentional}, explicit 
definition of both syntaxes, abstract and concrete: explicitly defining an 
instance $\mathsf{LI}$ requires a language defining $\mathsf{CS}$, and checking 
the conformance requires a language defining $\mathsf{AS}$, making 
$\mathsf{AS}$ and $\mathsf{CS}$ \emph{linguistic} instances of their respective 
\emph{languages}. Depending on the flavour of $\mathsf{CS}$, $\mathsf{L}$ is 
also coined as a \emph{visual} / \emph{diagrammatic} vs. \emph{textual} 
language.

According to Broman \emph{et al.} \cite{Broman-etAl:2012}, a language (called 
\emph{concrete formalism} in \cite{P:MPM:2006}) is ``a concrete implementation 
of formalism(s)``: for practical reasons, a language may rely on several 
formalisms, and may introduce semantics variations wrt. the formalism's 
semantics it implements. We formally capture the \emph{implementation} 
relationship between languages and formalisms.

\begin{Definition}[Implementation $\rightsquigarrow$]
   We write $\mathsf{L} \rightsquigarrow \mathsf{F_1}, \ldots, \mathsf{F_n}$ 
when the language $\mathsf{L}\in\mathbb{L}$ \emph{implements} the formalisms 
$\mathsf{F_1}, \ldots, \mathsf{F_n}\in\mathbb{F}$.
\end{Definition}
Automatically checking the implementation relation is difficult, and requires a 
mathematical machinerie way beyond the scope of this paper: software language 
designers use intricate combinations of formalism(s) to reach the current 
requirements for language usability, efficiency, readability, etc. Since the 
formalisms implemented by a language are transparent for the end-users, we 
focus our formalisation on languages rather than the formalisms: the 
implementation relation allows to retrieve them if needed.

\subsection{Transformations}
\label{sec:Formalisation-Transformation}

Transformations are the primary tool for capturing manipulations of language 
instances as part of a workflow. They may be arbitrarily complex, and come in 
different variations depending on their features \cite{J:Mens-VonGorp:2006} and 
properties and intents \cite{J:Lucio-Amrani-etAl:2014}. As usual, we 
distinguish between transformation \emph{specifications} and \emph{executions}.

\begin{Definition}[Transformation]
   A \emph{transformation specification} $\mathsf{T}\in\mathbb{T}$ is a triple 
$\mathsf{T} = ((\mathsf{L_s^{i}})_{\mathsf{i}\in [1..n]}, 
(\mathsf{L_t^{j}})_{\mathsf{j}\in[1..m]}, \mathsf{spec})$ where  
$(\mathsf{L_s^{i}})_{\mathsf{i}\in [1..n]}$ and
$(\mathsf{L_t^{j}})_{\mathsf{j}\in [1..m]}$ are indexed sets of source and
target languages, respectively, and $\mathsf{spec}$ is a well-formed 
transformation definition written in a transformation language.

   A \emph{transformation execution} $\mathsf{TE_{T}}$ is a general computation 
performed on (a) language instance(s) that conform(s) to the source language(s) 
of the transformation $\mathsf{T}\in\mathbb{T}$.
\end{Definition}


% Pursuing on our \textsc{Fsa} example, the \textsc{Uml} State Machines language
% \cite{} offers one concrete syntax to the \textsc{Fsa} formalism (by defining 
% how to represent initial, final and ''normal`` states), but also adds several 
% new concepts like hierarchical / orthogonal states, and reactions over 
% transitions (for facilitating design and integration with other \textsc{Uml} 
% languages, among other reasons) that impose to change the \textsc{Fsa} 
% semantics to take them into account.


% This leads to the usual distinction between 
% \emph{linguisting} and \emph{ontological} instantiation \cite{J:Kuhne:2006}: the 
% linguistic instantiation checks that an element $\mathsf{cs}$ is well-formed 
% regarding the concrete syntax $\mathsf{CS}$; while the ontological 
% instantiation checks the validity of $\mathsf{cs}$ regarding the concrete 
% definition of the abstract syntax $\mathsf{AS}$.


\subsection{Workflow}
\label{sec:Workflow}



\moussa{Would it be easier to define the xFTG+PM with \emph{languages} instead 
of \emph{formalisms}? This is what occurs in all FTG+PM I've seen anyway!}

\begin{Definition}{Transformation}
   
\end{Definition}



\begin{Definition}[Process Model]
   A \emph{process model} $\mathsf{PM}\in\PM$ is an instance of a 
\textsc{Uml} Activity Diagram where \textsf{ActionNode}s are labelled by 
transformation instance names, and may be \emph{hierarchical} and may contain 
input/output \textsf{Pins}; and \textsf{ObjectNode}s are labelled by language 
instance names; and \textsf{ControlNode}s include 
\textsf{Decision}/\textsf{Merge}, \textsf{Fork}/\textsf{Join} and 
\textsf{Init}/\textsf{Finals} nodes.
\end{Definition}



\subsection{Paradigmatic Structure}
\label{sec:PS}

\begin{Definition}[Paradigmatic Structure]
   A \emph{paradigmatic structure} $\mathsf{PS}\in \PS$ is a pair $\mathsf{PS} 
= (\mathsf{F}, \mathsf{W})$ where $\mathsf{F}\in \wp(\mathbb{F})$ is a set of 
formalisms and $\mathsf{W}\in\wp(\mathbb{W})$ is a set of workflows.
\end{Definition}

\moussa{Since Workflows are defined over languages, rather than formalisms, it 
makes sense here to adapt the definition accordingly.}
