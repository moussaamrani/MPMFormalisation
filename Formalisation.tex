\section{Formalisation}
\label{sec:Formalisation}

Our formalisation defines a \emph{paradigm} as a set of 
\emph{characterising properties} $\mathsf{\Pi}$ that holds over a mathematical 
construction called a \emph{paradigmatic structure} $\mathsf{PS}\in \PS$. 
This structure describes a specific \emph{workflow} (or \emph{process}) that 
captures how specific \emph{formalisms instances} are combined together, 
through transformations, towards achieving a specific intent $\iota$ that is 
adequately characterised by the properties. When $\iota$ has a commonly agreed 
name (in a given context, or for a specific community), and $\mathsf{\Pi}$ holds 
on a specific $\mathsf{PS}$, then $\mathsf{PS}$ is said to \emph{qualify} as 
the paradigm $\iota$. The properties constituting $\mathsf{\Pi}$ may 
characterise the formalisms and/or the workflow defining a paradigmatic 
structure. 

Take as a simple example \emph{object orientation} as a fairly recognised 
intent, which may translate into the following list of properties: the 
existence of objects possessing an identity; a notion of class that types 
objects, and that defines data and functions of these objects; a relation on 
classes called inheritence that allows objects of one class to acquire 
properties of objects of another class; and the existence of a message passing 
mechanism between objects. 
\moussa{Maybe factor out this description in a previous section dedicated to 
provide the intuition about paradigms?}. 


\begin{Definition}[Names]
   The sorted set \textsf{Name} of \emph{names} defines namespaces over 
\emph{items}.
   \begin{displaymath}
   \begin{small}
     \begin{array}{rcl}
		\mathsf{Item} & \eqdef & \{\mathsf{Language}, \mathsf{Transformation}, \\
                    &        & \mathsf{LangInstance}, \mathsf{TransInstance}\}\\
		\mathsf{Name}    & \eqdef & (\mathsf{Name}_{_{\mathsf{e}}})_{_{\mathsf{e} 
\in \mathsf{Item}}}
      \end{array}
   \end{small}
\end{displaymath}
\end{Definition}


\subsection{Formalism \& Language}
\label{sec:Formalism-Language}

\begin{Definition}[Formalism]
   A \emph{formalism} $F\in\mathbb{F}$ is a triple $F = (\mathsf{AS}, 
\SMapping, \mathsf{SD})$, where $\mathsf{AS}\in\AS$ is an \emph{abstract 
syntax}; $\mathsf{SD}\in\mathbb{D}$ is a \emph{semantic domain}; and $\SMapping 
\colon \mathsf{AS} \to \mathsf{SD}$ is a \emph{semantic mapping} that uniquely 
associates to each valid abstract syntax instance a meaning (or interpretation) 
in terms of the semantic domain.
\end{Definition}
A formalism is a mathematical construction that captures the \emph{essence}, 
the \emph{core concepts} of a software language. For example, Finite State 
Automata (\textsc{Fsa}), as originally defined by Moore \cite{J:Moore:1956}, 
define the 
state-transition computations. However, to be useful in practice, a 
\emph{concrete syntax} is needed in order to manipulate concrete instances, 
allowing the definition of languages.

 \begin{Definition}[Language]
   A \emph{language} $L\in\mathcal{L}$ is a tuple $L = (\mathsf{CS}, 
\mathsf{AS}, \SMapping, \mathsf{SD})$ where $\mathsf{CS}\in\CS$ is a 
\emph{concrete syntax} for representing elements of the language;  
$\mathsf{AS}\in\AS$ is an \emph{abstract syntax}; $\mathsf{SD}\in\mathbb{D}$ is 
a \emph{semantic domain}; and $\SMapping \colon \mathsf{AS} \to \mathsf{SD}$ is 
a \emph{semantic mapping}. 
\end{Definition}
A language, also known as a \emph{concrete formalism} \cite{P:MPM:2006}, is ``a 
concrete implementation of formalism(s)``: according to Broman \emph{et al.} 
\cite{Broman-etAl:2012}, a language may rely on several formalisms, and may 
deviate slightly from the formalisms' semantics it implements. 

Pursuing on our \textsc{Fsa} example, the \textsc{Uml} State Machines language
\cite{} offers one concrete syntax to the \textsc{Fsa} formalism (by defining 
how to represent initial, final and ''normal`` states), but also adds several 
new concepts like hierarchical / orthogonal states, and reactions over 
transitions (for facilitating design and integration with other \textsc{Uml} 
languages, among other reasons) that impose to change the \textsc{Fsa} 
semantics to take them into account.

Note that our previous definitions are \emph{extentional} in nature, as 
illustrated in Figure \ref{fig:FrameworkSets}. In practice, several languages 
shall be selected for the purpose of concretely defining of a formalism and 
of a language. In the Model-Driven Engineering approach, metamodelling
languages (based on graphs or the \textsc{Omg Mof} standard) are preferred for 
the abstract syntax (although grammars are another valid choice), together 
with model transformations for expressing semantic mappings.  

% This leads to the usual distinction between 
% \emph{linguisting} and \emph{ontological} instantiation \cite{J:Kuhne:2006}: the 
% linguistic instantiation checks that an element $\mathsf{cs}$ is well-formed 
% regarding the concrete syntax $\mathsf{CS}$; while the ontological 
% instantiation checks the validity of $\mathsf{cs}$ regarding the concrete 
% definition of the abstract syntax $\mathsf{AS}$.


\subsection{Workflow}
\label{sec:Workflow}

\moussa{Would it be easier to define the xFTG+PM with \emph{languages} instead 
of \emph{formalisms}? This is what occurs in all FTG+PM I've seen anyway!}

\begin{Definition}{Transformation}
   
\end{Definition}



\begin{Definition}[Process Model]
   A \emph{process model} $\mathsf{PM}\in\PM$ is an instance of a 
\textsc{Uml} Activity Diagram where \textsf{ActionNode}s are labelled by 
transformation instance names, and may be \emph{hierarchical} and may contain 
input/output \textsf{Pins}; and \textsf{ObjectNode}s are labelled by language 
instance names; and \textsf{ControlNode}s include 
\textsf{Decision}/\textsf{Merge}, \textsf{Fork}/\textsf{Join} and 
\textsf{Init}/\textsf{Finals} nodes.
\end{Definition}



\subsection{Paradigmatic Structure}
\label{sec:PS}

\begin{Definition}[Paradigmatic Structure]
   A \emph{paradigmatic structure} $\mathsf{PS}\in \PS$ is a pair $\mathsf{PS} 
= (\mathsf{F}, \mathsf{W})$ where $\mathsf{F}\in \wp(\mathbb{F})$ is a set of 
formalisms and $\mathsf{W}\in\wp(\mathbb{W})$ is a set of workflows.
\end{Definition}

\moussa{Since Workflows are defined over languages, rather than formalisms, it 
makes sense here to adapt the definition accordingly.}
