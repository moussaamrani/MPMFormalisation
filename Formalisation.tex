\section{Formalisation}
\label{sec:Formalisation}

Our formalisation defines a \emph{paradigm} as a set of 
\emph{characterising properties} $\mathsf{\Pi}$ that holds over a mathematical 
construction called a \emph{paradigmatic structure} $\mathsf{PS}\in \PS$. 
This structure describes a specific \emph{workflow} (or \emph{process}) that 
captures how specific \emph{languages instances} are combined together, 
through transformations, towards achieving a specific intent $\iota$ that is 
adequately characterised by the properties. When $\iota$ has a commonly agreed 
name (in a given context, or for a specific community), and $\mathsf{\Pi}$ holds 
on a specific $\mathsf{PS}$, then $\mathsf{PS}$ is said to \emph{qualify} as 
the paradigm $\iota$. The properties constituting $\mathsf{\Pi}$ may 
characterise the formalisms and/or the workflow defining a paradigmatic 
structure. 

\subsection{Preliminaries}
\label{sec:Formalisation-Preliminaries}

We assume in this paper that ``\emph{everything is modelled explicitly}`` by 
using \emph{models} conformant to \emph{metamodels}, themselves explicitly 
modelled (using a \emph{meta-metamodel}). The following definition introduces 
precise notations for these notions.

\begin{Definition}[(Meta-)Models \& Conformance]
   Let $\mathbb{M}$ and $\mathcal{M}$ be the sets of all models and metamodels 
respectively, as defined by meta-metamodels. For a model $\mathsf{M} \in 
\mathbb{M}$ and a metamodel $\mathsf{MM} \in \mathcal{M}$, we write $\mathsf{M} 
\rhd \mathsf{MM}$ if $\mathsf{M}$ \emph{conforms to} $\mathsf{MM}$.
\end{Definition}
This definition explicitly distinguishes between two meanings for what is 
called an \emph{instance}, namely the difference between \emph{linguistic} and 
\emph{ontological} instantiation \cite{J:Kuhne:2006}. \textsf{M} and \textsf{MM} 
are \emph{valid} (linguistic) instances of their respective meta-metamodels in 
the sense that they belong to the valid ''\emph{phrases}'' that the 
meta-metamodel defines; whereas the fact that \textsf{M} is an 
\emph{ontological} instance of \textsf{MM} needs to be checked, making 
\textsf{M} conform to \emph{MM}. This checking procedure has been extensively 
described by many previous contributions (see e.g. \cite{PhD:Amrani:2013}).

The choice of a specific meta-metamodel determines the thechnological space 
chosen for metamodelling \cite{Wimmer-Kramler:2005}: \emph{grammarware} have a 
tree-based structure and are fully textual; whereas \emph{modelsware} are either 
visual or textual (or both), and rely either on \textsc{Mof}-like tree-based 
(meta-)metamodels, or Graph Theory. 


% Take as a simple example \emph{object orientation} as a fairly recognised 
% intent, which may translate into the following list of properties: the 
% existence of objects possessing an identity; a notion of class that types 
% objects, and that defines data and functions of these objects; a relation on 
% classes called inheritence that allows objects of one class to acquire 
% properties of objects of another class; and the existence of a message passing 
% mechanism between objects. 
% \moussa{Maybe factor out this description in a previous section dedicated to 
% provide the intuition about paradigms?}. 

In order to designate specific items of our formalisation explicitly by their 
name, we define distinct namespaces as sorted sets. Properly resolving 
namespaces is out of scope, as it relies on specific tooling 
capabilities and implementation choices.

\begin{Definition}[Names]
   The sorted set $\mathsf{Name}$ of \emph{names} defines namespaces over 
\emph{items}.
   \begin{small}
   \begin{displaymath}
     \begin{array}{rcl}
		\mathsf{Item} & \eqdef & \{\mathsf{Language}, \mathsf{Transformation}, \\
                    &        & \mathsf{LangInstance}, \mathsf{TransInstance}\}\\
		\mathsf{Name}    & \eqdef & (\mathsf{Name}_{_{\mathsf{e}}})_{_{\mathsf{e} 
\in \mathsf{Item}}}
      \end{array}
\end{displaymath}
   \end{small}
\end{Definition}
To avoid the subscripted notation, we introduce a more compact notation for 
referring to names: for example, the set of class names 
$\mathsf{Name_{_{Language}}}$ will be noted $\mathsf{LanguageN}$.  

\subsection{Formalism \& Language}
\label{sec:Formalism-Language}

We first introduce a distinction between \emph{formalisms} and \emph{languages}: 
a \emph{formalism} is a mathematical construction built for capturing the 
\emph{essence} and the \emph{core concepts} of a software \emph{language}. 

\begin{Definition}[Formalism]
   A \emph{formalism} $F\in\mathbb{F}$ is a triple $F = (\mathsf{AS}, 
\SMapping, \mathsf{SD})$, where $\mathsf{AS}\in\mathcal{M}$ is a metamodel 
defining an \emph{abstract syntax}; $\mathsf{SD}\in\mathbb{D}$ is a 
\emph{semantic domain}; and $\SMapping 
\colon \mathsf{AS} \to \mathsf{SD}$ is a \emph{semantic mapping} that uniquely 
associates to each valid abstract syntax instance a meaning (or interpretation) 
in terms of the semantic domain.
\end{Definition}

Translating the core concepts captured by a formalism into a usable software 
language requires the definition of a \emph{concrete semantics} for 
users/modellers to manipulate language instances.


 \begin{Definition}[Language]
   A \emph{language specification} (or \emph{language} 
for short) $\mathsf{L}\in\mathbb{L}$ is a tuple $\mathsf{L} = (\mathsf{CS}, 
\mathsf{AS}, \SMapping, \mathsf{SD})$ where $\mathsf{CS}\in\mathcal{M}$ is a 
\emph{concrete syntax} for representing elements of the language;  
$\mathsf{AS}\in\mathcal{M}$ is an \emph{abstract syntax}; 
$\mathsf{SD}\in\mathbb{D}$ is 
a \emph{semantic domain}; and $\SMapping \colon \mathsf{AS} \to \mathsf{SD}$ is 
a \emph{semantic mapping}. 

   A \emph{language instance} $\mathsf{LI}\in\mathbb{M}$ of a language 
$\mathsf{L}\in\mathbb{L}$ is a model conform to $\mathsf{AS}$ (i.e. 
$\mathsf{LI} \rhd \mathsf{AS}$) and defined using \textsf{CS}.
\end{Definition}

\smallskip\noindent
Our definition for languages is \emph{extentional}: it only specifies the sets 
involved in the structure of a language (as advocated e.g. by Harel \& Rumpe 
\cite{J:Harel-Rumpe:2004}), without providing a constructing approach to 
manipulate them. However, effectively checking that a language instance 
conforms to its specification requires an \emph{intentional}, explicit 
definition of both syntaxes, abstract and concrete: explicitly defining an 
instance $\mathsf{LI}$ requires a language defining $\mathsf{CS}$, and checking 
the conformance requires a language defining $\mathsf{AS}$, making 
$\mathsf{AS}$ and $\mathsf{CS}$ \emph{linguistic} instances of their respective 
\emph{languages}. Depending on the flavour of $\mathsf{CS}$, $\mathsf{L}$ is 
also coined as a \emph{visual} / \emph{diagrammatic} vs. \emph{textual} 
language.

According to Broman \emph{et al.} \cite{Broman-etAl:2012}, a language (called 
\emph{concrete formalism} in \cite{P:MPM:2006}) is ``a concrete implementation 
of formalism(s)``: for practical reasons, a language may rely on several 
formalisms, and may introduce semantics variations wrt. the formalism's 
semantics it implements. We formally capture the \emph{implementation} 
relationship between languages and formalisms.

\begin{Definition}[Implementation $\rightsquigarrow$]
   We write $\mathsf{L} \rightsquigarrow \mathsf{F_1}, \ldots, \mathsf{F_n}$ 
when the language $\mathsf{L}\in\mathbb{L}$ \emph{implements} the formalisms 
$\mathsf{F_1}, \ldots, \mathsf{F_n}\in\mathbb{F}$.
\end{Definition}
Automatically checking the implementation relation is difficult, and requires a 
mathematical machinerie way beyond the scope of this paper: software language 
designers use intricate combinations of formalism(s) to reach the current 
requirements for language usability, efficiency, readability, etc., blurring 
this relations along the way. 
Since the formalisms implemented by a language are transparent for the 
end-users, we focus our formalisation on languages rather than the formalisms: 
the implementation relation allows to retrieve them if needed.

\begin{Example}{Variations over \textsc{Fsm}s.}
   
\end{Example}



\subsection{Transformations}
\label{sec:Formalisation-Transformation}

Transformations are the primary tool for capturing manipulations of language 
instances as part of a workflow. They may be arbitrarily complex, and come in 
different variations depending on their features \cite{J:Mens-VonGorp:2006} and 
properties and intents \cite{J:Lucio-Amrani-etAl:2014}. As usual, we 
distinguish between transformation \emph{specifications} and \emph{executions}.

\begin{Definition}[Transformation\label{def:Transformation}]
   A \emph{transformation specification} $\mathsf{T}\in\mathbb{T}$ is a triple 
$\mathsf{T} = ((\mathsf{L_s^{i}})_{\mathsf{i}\in [1..n]}, 
(\mathsf{L_t^{j}})_{\mathsf{j}\in[1..m]}, \mathsf{spec})$ where  
$(\mathsf{L_s^{i}})_{\mathsf{i}\in [1..n]}$ and
$(\mathsf{L_t^{j}})_{\mathsf{j}\in [1..m]}$ are indexed sets of source and
target languages, respectively, and $\mathsf{spec}$ is a well-formed 
transformation definition written in a transformation language.

   A \emph{transformation execution} $\mathsf{TE_{T}}\in\TE$ is a general 
computation performed on (a) language instance(s) that conform(s) to the source 
language(s) of the transformation $\mathsf{T}\in\mathbb{T}$.
\end{Definition}
For the purpose of formalising the notion of paradigm, the details on how 
$\mathsf{spec}$ is written have less importance than the ''signature`` of 
a transformation, i.e. which languages are taken as sources and produced as 
targets. We then simplify the notation by defining a transformation as pair, 
without $\mathsf{spec}$.

% Pursuing on our \textsc{Fsa} example, the \textsc{Uml} State Machines language
% \cite{} offers one concrete syntax to the \textsc{Fsa} formalism (by defining 
% how to represent initial, final and ''normal`` states), but also adds several 
% new concepts like hierarchical / orthogonal states, and reactions over 
% transitions (for facilitating design and integration with other \textsc{Uml} 
% languages, among other reasons) that impose to change the \textsc{Fsa} 
% semantics to take them into account.


% This leads to the usual distinction between 
% \emph{linguisting} and \emph{ontological} instantiation \cite{J:Kuhne:2006}: the 
% linguistic instantiation checks that an element $\mathsf{cs}$ is well-formed 
% regarding the concrete syntax $\mathsf{CS}$; while the ontological 
% instantiation checks the validity of $\mathsf{cs}$ regarding the concrete 
% definition of the abstract syntax $\mathsf{AS}$.

\begin{Example}
   
\end{Example}


\subsection{Workflow}
\label{sec:Workflow}

Workflows constitute the essence of a paradigm: they describe precisely how 
formalisms (or more precisely, languages) are related to each other through 
transformations, in order to achieve an expected intent. 
A workflow is composed of two elements: a \emph{Formalism Transformation Graph} 
(\textsc{Ftg}) describes explicitly the links between formalisms / languages, 
stating what possible transformations may be used; and a \emph{Process Model} 
(\textsc{Pm}) describes how language instances are 
combined together to achieve the intent $\iota$. Combining both elements 
results in the \textsc{Ftg+Pm} formalism and language that has already been 
described in \cite{}.

Before providing a definition of \textsc{Ftg+Pm}, we need to introduce a naming 
mechanism: instead of directly manipulating languages and transformations, a 
repository links the names used by an \textsc{Ftg+Pm} to their actual items. 
This linking is formally captured by the following definition:


\moussa{Would it be easier to define the xFTG+PM with \emph{languages} instead 
of \emph{formalisms}? This is what occurs in all FTG+PM I've seen anyway!}

\begin{Definition}[Naming]
   Two \emph{naming functions} associate (sorted) names to their actual item:
   \begin{displaymath}
      \begin{array}{rcl}
         trans &\colon& \mathsf{TransformationN} \to \mathbb{T}\\
         lang  &\colon& \mathsf{LanguageN} \to \mathbb{L}
      \end{array}
   \end{displaymath}
\end{Definition}

An \textsc{Ftg} can be seen as a collection of transformations that are 
considered useful for a given context. Since transformation names are actually 
used, we use a functional definition.
\begin{Definition}{Formalism Transformation Graph (\textsc{Ftg})}
   A \emph{Formalism Transformation Graph} $\mathsf{FTG} \in \FTG(L, T)$ is a 
function  $\mathsf{FTG} \colon T \to \langle L \rangle \times \langle L \rangle 
\times \mathbb{B}$ restricted to specific subsets of languages $L \subseteq 
\mathsf{LanguageN}$ and transformations $T\subseteq \mathsf{TransformationN}$, 
and the boolean value indicates whether the transformation is automatic or not 
(meaning that it becomes a human activity).
\end{Definition}
Note that the definition uses sequences of source and target languages to 
ensure that a specific transformation execution correctly instantiate its 
specification (cf. Def. \ref{def:Transformation}).

In practice, we represent \textsf{FTG} with colored rounds for transformations 
(names) to distinguish between automatic and manual ones, and shared rectangles 
for languages (names).

\medskip
As its name indicates, a \textsc{Pm} describes a process, i.e. a set of 
activities that are combined together towards achieving a particular goal. 
Instead of reinventing a Domain-Specific Language for this well-studied domain, 
we simply specialise one standard and well-known language that covers our 
needs, namely \textsc{Uml}'s Activity Diagrams.

\begin{Definition}[Process Model (\textsc{Pm})]
   A \emph{process model} $\mathsf{PM}\in\PM$ is an instance of a 
\textsc{Uml} Activity Diagram where 
\begin{itemize}
   \item \textsf{ActionNode}s are labelled by transformation instance names 
typed by their conforming transformation specifications, and may be 
\emph{hierarchical} and may contain input/output \textsf{Pins}; and 
   \item \textsf{ObjectNode}s are labelled by language instance names typed by 
their conforming languages; and 
   \item \textsf{ControlNode}s include \textsf{Decision}/\textsf{Merge}, 
\textsf{Fork}/\textsf{Join} and \textsf{Init}/\textsf{Finals} nodes.   
\end{itemize}
\end{Definition}
We may distinguish in the concrete syntax \textsf{ControlFlow}s from 
\textsf{ObjectFlow}s to emphasize the control and make the process more 
proeminent. We assume that \textsf{ActionNode} names and \textsf{ObjectNode} 
names are distinct and unique. We also require that \textsc{Pm}s are 
well-formed wrt. their \textsc{Ftg}.

\begin{Deifnition}[\textsc{Pm} Well-Formedness]
   A process model $\mathsf{PM}\in\PM$ is \emph{well-formed} wrt. a 
transformation graph $\mathsf{FTG} \in \FTG(L, T)$ iff:
\begin{itemize}
   \item the type names of transformation instances appearing in 
\textsf{ActionNode}s (resp. language instances appearing in \textsf{ObjectNode}) 
belongs to $T$ (resp. $L$);
   \item all transformation instances names appearing in \textsf{ActionNode}s
\end{itemize}

\end{Deifnition}


\medskip
\moussa{Define the typing relation for a \textsc{Pm} relatively to an 
\textsc{Ftg}.}

\moussa{Define the extended version x\textsc{Ftg} and explore the implications.}

\medskip
The following definition simply puts things together: a workflow is composed of 
an \textsc{Ftg} together with several well-typed \textsc{Pm}s. 

\begin{Definition}[Workflow]
   A \emph{workflow} $\mathsf{W}\in\mathbb{W}$ is a pair $\mathsf{W} = 
(\mathsf{FTG}), P)$ where $\mathsf{FTG}\in\FTG$ and $P\in\wp(\PM)$, such that 
all $\mathsf{P}\in P$ is well-typed: $\mathsf{P} ? \mathsf{FTG}$.
\end{Definition}



\subsection{Paradigmatic Structure}
\label{sec:PS}

\begin{Definition}[Paradigmatic Structure]
   A \emph{paradigmatic structure} $\mathsf{PS}\in \PS$ is a pair $\mathsf{PS} 
= (L, W)$ where $L\in \wp(\mathbb{L})$ is a set of languages and 
$W \in \wp(\mathbb{W})$ is a set of workflows.
\end{Definition}

