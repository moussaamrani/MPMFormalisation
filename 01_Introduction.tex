\section{Introduction}
\label{sec:Introduction}

Modern General-Purpose Programming Languages (\textsc{gpl}s) are traditionally
classified according to their supporting paradigm(s).
For example, Eiffel is object-oriented and supports the contract-based-design
paradigm, Prolog is declarative, and Lisp is functional. The paradigm
characterises the underlying syntactic and semantic structures and principles
that govern these \textsc{gpl}s: object orientation is imperative in nature and
imposes viewing the world in terms of classes and communicating objects whereas the
declarative style relies on term substitution and rewriting.
This has a concrete consequence for users: a statement in Eiffel has very little
in common with a Prolog sentence due to the very different view supported by
both languages on the system under specification.
A programming paradigm directly translates into different concepts encoded in
the \textsc{gpl}'s language syntax definition (known as a metamodel in the
Model-Driven Engineering world).
Very naturally, the idea of combining several paradigms at the level of
\textsc{gpl}s led to more expressive, powerful programming languages such as
Java (which is imperative, object-oriented, concurrent, and real-time and,
recently, functional) and Maude (which is declarative, object-oriented and also
concurrent and real-time).
% HV: add citations to all the languages above HV: add reference to the '90s
% multi-paradigm programming language Leda?
% https://www.goodreads.com/book/show/8129222-multiparadigm-programming-in-leda
What is a \emph{paradigm} then? The science philosopher Kuhn \cite{B:Kuhn:2012}
%while investigating how science evolves through paradigm shifts d
defines it as an
open-ended contribution that frames the thinking of an object study with
concepts, results and procedures that structures future achievements. Though
seemingly far from the concerns in the discipline of Computer Science, this
definition nevertheless highlights the emergence of a \emph{structure} that
captures the object of discourse, and the notion of \emph{procedure} that guides
achievements.

Multi-Paradigm Modelling (\textsc{mpm}) has been recognised lately as a powerful
paradigm in its own right that may be helpful in designing, as well as
communicating and reasoning about, Cyber-Physical Systems (\textsc{cps}).
\textsc{cps} emerge from the networking of multi-physical  (mechanical,
electrical, biochemical, \ldots) and computational (control, signal processing,
logical inference, planning, \ldots) processes, often interacting with a highly
uncertain environment, including human actors, in a socio-economic context.
\textsc{cps} are notoriously complex because they cross discipline borders,
leading to inter-domain interactions, in applications that are often
safety-critical.

We propose a formal framework capturing the notion of
\emph{paradigm} as a first step towards a formal framework for \textsc{mpm}
(with foremost application in \textsc{cps}).
Beyond the mathematical specification, this formal framework aims to facilitate
the communication between experts to help them better grasp the essence of how
their \textsc{cps} are built, but also to facilitate a rigorous comparison of
systems based on their core \textsc{mpm} components.
Ultimately, this framework aims to support (meta-)tool builders who assist
practitioners to reason about \textsc{cps} and figure out which formalisms,
abstractions, workflows and supporting methods, techniques and tools are the
\emph{most appropriate} to carry out their task(s).

Section \ref{sec:Motivation} motivates our work.
Section \ref{sec:Formalisation} sketches a 
formal framework proposal addressing the notion of paradigms.
Section \ref{sec:CS} introduces the small CookieCAD paradigm. 
Section \ref{sec:Conclusion} discusses related work and concludes.

% \hans{Explain the context: assuming MPM works for modelling CPS, why do we need a formalisation? Communication, Comparison, tool building}
% \dominique{Explain the context: assuming MPM works for modelling CPS, why do we need a formalisation? Communication, Comparison, tool building}
% Programming paradigms are approaches to solve problems using programming languages, tools and techniques following some methodologies and strategies. Such paradigms are often classified into the categories of imperative (procedural, object oriented, parallel processing, etc.) and declarative (logic, functional, database, etc.) paradigms []. While early programming languages were mostly single paradigm (e.g. procedural for Fortran and functional for Lisp), nowadaysâ€™ programming languages are often multi-paradigm in an attempt to help solving more complex problems. Such is the case of Java that supports procedural and object oriented paradigms, and that has add-ons to support parallel processing, and functional programming since its version 8. The introduction of such high level programming languages and their supporting paradigms allowed significant increase in productivity and to develop software that we would not have been able to develop at affordable costs otherwise using only first and second generation languages such as machine code and assembly languages. In addition, often several programming languages based on different paradigms are employed for the development of nowadays software. 
% 
% Cyber-Physical systems that integrate physical, software and networks asp   ects are becoming more and more complex and expensive to develop, mostly due to cross-disciplinary design and their inter-domain interactions. Model-Based Engineering (MBE) is a paradigm created to tackle this complexity, where models of high levels of abstraction are used to specify the system instead of natural language documents and low level programming code, which is instead generated from these models. Compared to traditional development methods, MBE allows developing more complex systems with significantly reduced development costs [].
% 
% Like for programming, model-based engineering makes use of several paradigms to solve specific problems. For example, if the behaviour of a system can be described by operations triggered by the availability of data, then the data flow paradigm would be most appropriate for designing this system. This paradigm then helps choosing the formalisms to be employed to design the system. Similarly, if requirements are likely to change during the course of a project, then an agile paradigm will be appropriate. This paradigm will help defining the development process of the project. 
% 
% Such paradigms can therefore be used to characterise different parts of the modelling scenarios employed for CPS development. Such modelling scenarios typically consist of modelling languages, tools and techniques with some workflows. Like for the case of programming languages, a modelling scenario may employ several paradigms or several single-paradigm modelling scenarios may be employed sequentially during CPS development. Modelling scenarios are the basis of Multi-Paradigm Modelling (MPM) that offers a foundational framework for developing CPSs by gluing the several disciplines together in a consistent way and by breaking down the complexity of CPSs into different levels of abstraction and views expressed with appropriate formalisms.
% Therefore, like for programming, modelling paradigms are the essence of MPM. 
% In this work, which started during the MPM4CPS COST action and was pursued during the CAMPaM research seminar, we propose a formalisation of the notion of modelling paradigms. The objectives of this formalisation are to allow better understanding of MPM and to help selecting the artefacts such as formalisms, tools and development processes when creating  the modelling scenarios used for CPSs development projects. 
% 
% We illustrate our formalisation with a basic modelling paradigm: the CAD (Computer Aided Design) paradigm. CAD is an excellent example for our formalisation. Since its introduction in the mid 1960s, it has constantly been improved by the addition of new paradigms in order to improve productivity and quality of designs\footnote{See \url{http://www.tecnetinc.com/conceptual\%20design-1.html} for an interesting discussion on CAD paradigms.}. Examples of such additional paradigms are 3D wireframes, surface modelling, solid modelling and environmental paradigms to name a few. While in this paper we only consider the basic CAD paradigm, these evolutions can provide a rich case study to extends this work, in addition to the more heterogeneous modelling paradigms employed for CPS development.
% 
% The rest of this paper is divided as follows: TODO.

